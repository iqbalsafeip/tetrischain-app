"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("components_main_index_js",{

/***/ "./utils/general.js":
/*!**************************!*\
  !*** ./utils/general.js ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canMove: function() { return /* binding */ canMove; },\n/* harmony export */   clearLines: function() { return /* binding */ clearLines; },\n/* harmony export */   collides: function() { return /* binding */ collides; },\n/* harmony export */   displayWallet: function() { return /* binding */ displayWallet; },\n/* harmony export */   formatDateComparable: function() { return /* binding */ formatDateComparable; },\n/* harmony export */   formatNumber: function() { return /* binding */ formatNumber; },\n/* harmony export */   formatShortNumber: function() { return /* binding */ formatShortNumber; },\n/* harmony export */   getRandClearSound: function() { return /* binding */ getRandClearSound; },\n/* harmony export */   getShadowPosition: function() { return /* binding */ getShadowPosition; },\n/* harmony export */   mergeTetromino: function() { return /* binding */ mergeTetromino; },\n/* harmony export */   mergeTetrominoPrev: function() { return /* binding */ mergeTetrominoPrev; },\n/* harmony export */   randomTetromino: function() { return /* binding */ randomTetromino; },\n/* harmony export */   rotateMatrix: function() { return /* binding */ rotateMatrix; },\n/* harmony export */   sortByField: function() { return /* binding */ sortByField; },\n/* harmony export */   toAudio: function() { return /* binding */ toAudio; },\n/* harmony export */   updateRawMetaBulk: function() { return /* binding */ updateRawMetaBulk; }\n/* harmony export */ });\n/* harmony import */ var _components_config_audio__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/config/audio */ \"./components/config/audio.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant */ \"./utils/constant.js\");\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./supabase */ \"./utils/supabase.js\");\nvar _s = $RefreshSig$();\n\n\n\n\nconst toAudio = (src)=>{\n    _s();\n    const temp = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Audio(src));\n    return temp.current;\n};\n_s(toAudio, \"MH7sb5i/20gVa+oj8M+G2j2iqDw=\");\nconst getRandClearSound = (_)=>{\n    const getRand = ()=>{\n        const num = Math.round(Math.random() * 5) + 1;\n        const clearAudio = _components_config_audio__WEBPACK_IMPORTED_MODULE_0__[\"default\"].blockClear(num);\n        return clearAudio;\n    };\n    return getRand();\n};\nconst displayWallet = (address)=>{\n    return address.slice(0, 6) + (address.length > 6 ? \"....\" : \"\") + address.slice(address.length - 6, address.length);\n};\nfunction formatShortNumber(n) {\n    if (n >= 1000000) return (n / 1000000).toFixed(1).replace(/\\.0$/, \"\") + \"M\";\n    if (n >= 1000) return (n / 1000).toFixed(1).replace(/\\.0$/, \"\") + \"K\";\n    return n.toString();\n}\nfunction formatDateComparable(dateInput) {\n    const date = new Date(dateInput);\n    const day = String(date.getDate()).padStart(2, \"0\");\n    const month = String(date.getMonth() + 1).padStart(2, \"0\"); // Months are 0-indexed\n    const year = date.getFullYear();\n    return \"\".concat(year, \"-\").concat(month, \"-\").concat(day);\n}\nfunction formatNumber(n) {\n    return n.toLocaleString();\n}\nconst rotateMatrix = (matrix)=>matrix[0].map((_, i)=>matrix.map((row)=>row[i]).reverse());\nconst randomTetromino = ()=>{\n    const index = Math.floor(Math.random() * _constant__WEBPACK_IMPORTED_MODULE_2__.tetrominos.length);\n    return {\n        shape: _constant__WEBPACK_IMPORTED_MODULE_2__.tetrominos[index],\n        color: _constant__WEBPACK_IMPORTED_MODULE_2__.futuristicColors[index],\n        row: 0,\n        col: 3\n    };\n};\nconst canMove = function(grid, tetromino) {\n    let offsetRow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, offsetCol = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, shape = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;\n    const shapeToCheck = shape || tetromino.shape;\n    return shapeToCheck.every((row, rIdx)=>row.every((val, cIdx)=>{\n            if (!val) return true;\n            const newRow = tetromino.row + rIdx + offsetRow;\n            const newCol = tetromino.col + cIdx + offsetCol;\n            return newRow >= 0 && newRow < _constant__WEBPACK_IMPORTED_MODULE_2__.board.gridHeight && newCol >= 0 && newCol < _constant__WEBPACK_IMPORTED_MODULE_2__.board.gridWidth && grid[newRow][newCol] === 0;\n        }));\n};\nconst collides = function(grid, tetromino) {\n    let rowOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, colOffset = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;\n    const { shape, row: tRow, col: tCol } = tetromino;\n    for(let r = 0; r < shape.length; r++){\n        for(let c = 0; c < shape[r].length; c++){\n            if (!shape[r][c]) continue; // Skip empty cells\n            const y = tRow + r + rowOffset;\n            const x = tCol + c + colOffset;\n            // Outside vertical bounds (bottom of grid)\n            if (y >= grid.length) return true;\n            // Outside horizontal bounds\n            if (x < 0 || x >= grid[0].length) return true;\n            // Colliding with a filled cell (only check if inside vertical bounds)\n            if (y >= 0 && grid[y][x]) return true;\n        }\n    }\n    return false; // No collision\n};\nconst getShadowPosition = (grid, tetromino)=>{\n    const shadow = {\n        ...tetromino,\n        row: tetromino.row\n    };\n    while(!collides(grid, shadow, 1, 0)){\n        shadow.row += 1;\n    }\n    return shadow;\n};\nconst mergeTetromino = function(grid, tetromino) {\n    let shadowTetromino = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n    const newGrid = grid.map((row)=>[\n            ...row\n        ]);\n    if (shadowTetromino) {\n        shadowTetromino.shape.forEach((row, rIdx)=>{\n            row.forEach((val, cIdx)=>{\n                if (val) {\n                    const y = shadowTetromino.row + rIdx;\n                    const x = shadowTetromino.col + cIdx;\n                    if (y >= 0 && y < _constant__WEBPACK_IMPORTED_MODULE_2__.board.gridHeight && x >= 0 && x < _constant__WEBPACK_IMPORTED_MODULE_2__.board.gridWidth && newGrid[y][x] === 0) {\n                        // Use a negative or special value for shadow\n                        newGrid[y][x] = -1; // or a separate constant like SHADOW_CELL = -1;\n                    }\n                }\n            });\n        });\n    }\n    tetromino.shape.forEach((row, rIdx)=>{\n        row.forEach((val, cIdx)=>{\n            if (val) {\n                const y = tetromino.row + rIdx;\n                const x = tetromino.col + cIdx;\n                if (y >= 0 && y < _constant__WEBPACK_IMPORTED_MODULE_2__.board.gridHeight && x >= 0 && x < _constant__WEBPACK_IMPORTED_MODULE_2__.board.gridWidth) {\n                    const colorIndex = _constant__WEBPACK_IMPORTED_MODULE_2__.futuristicColors.indexOf(tetromino.color);\n                    if (colorIndex !== -1) {\n                        newGrid[y][x] = colorIndex + 1;\n                    }\n                }\n            }\n        });\n    });\n    return newGrid;\n};\nconst mergeTetrominoPrev = (grid, tetromino)=>{\n    const newGrid = grid.map((row)=>[\n            ...row\n        ]);\n    tetromino.shape.forEach((row, rIdx)=>{\n        row.forEach((val, cIdx)=>{\n            if (val) {\n                const y = tetromino.row + rIdx + 1;\n                const x = tetromino.col + cIdx - 2;\n                if (y >= 0 && y < _constant__WEBPACK_IMPORTED_MODULE_2__.board.gridHeightPrev && x >= 0 && x < _constant__WEBPACK_IMPORTED_MODULE_2__.board.gridWidthPrev) {\n                    const colorIndex = _constant__WEBPACK_IMPORTED_MODULE_2__.futuristicColors.indexOf(tetromino.color);\n                    if (colorIndex !== -1) {\n                        newGrid[y][x] = colorIndex + 1;\n                    }\n                }\n            }\n        });\n    });\n    return newGrid;\n};\nconst clearLines = (grid)=>{\n    let cleared = 0;\n    const newGrid = grid.filter((row)=>{\n        if (row.every((cell)=>cell !== 0)) {\n            cleared++;\n            return false;\n        }\n        return true;\n    });\n    const clearedRows = [];\n    grid.forEach((row, y)=>{\n        if (row.every((cell)=>cell > 0)) {\n            clearedRows.push(y);\n        }\n    });\n    while(newGrid.length < _constant__WEBPACK_IMPORTED_MODULE_2__.board.gridHeight){\n        newGrid.unshift(Array(_constant__WEBPACK_IMPORTED_MODULE_2__.board.gridWidth).fill(0));\n    }\n    return {\n        newGrid,\n        cleared,\n        clearedRows\n    };\n};\nfunction sortByField(arr, field) {\n    let ascending = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n    return arr.slice().sort((a, b)=>{\n        if (a[field] < b[field]) return ascending ? -1 : 1;\n        if (a[field] > b[field]) return ascending ? 1 : -1;\n        return 0;\n    });\n}\nasync function updateRawMetaBulk(score, id) {\n    try {\n        await _supabase__WEBPACK_IMPORTED_MODULE_3__.supabase.from(\"leaderboard\").update({\n            score: score\n        }).eq(\"user_id\", id);\n    } catch (error) {}\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlscy9nZW5lcmFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDZjtBQUNrQztBQUMzQjtBQUUvQixNQUFNTSxVQUFVQyxDQUFBQTs7SUFDbkIsTUFBTUMsT0FBT1AsNkNBQU1BLENBQUMsSUFBSVEsTUFBTUY7SUFFOUIsT0FBT0MsS0FBS0UsT0FBTztBQUN2QixFQUFDO0dBSllKO0FBTU4sTUFBTUssb0JBQW9CQyxDQUFBQTtJQUM3QixNQUFNQyxVQUFVO1FBQ1osTUFBTUMsTUFBTUMsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUssS0FBSztRQUM1QyxNQUFNQyxhQUFhbEIsMkVBQWdCLENBQUNjO1FBQ3BDLE9BQU9JO0lBQ1g7SUFFQSxPQUFPTDtBQUNYLEVBQUM7QUFFTSxNQUFNTyxnQkFBZ0JDLENBQUFBO0lBQ3pCLE9BQU9BLFFBQVFDLEtBQUssQ0FBQyxHQUFHLEtBQU1ELENBQUFBLFFBQVFFLE1BQU0sR0FBRyxJQUFJLFNBQVMsRUFBQyxJQUFLRixRQUFRQyxLQUFLLENBQUNELFFBQVFFLE1BQU0sR0FBRyxHQUFHRixRQUFRRSxNQUFNO0FBQ3RILEVBQUM7QUFFTSxTQUFTQyxrQkFBa0JDLENBQUM7SUFDakMsSUFBSUEsS0FBSyxTQUFXLE9BQU8sQ0FBQ0EsSUFBSSxPQUFRLEVBQUdDLE9BQU8sQ0FBQyxHQUFHQyxPQUFPLENBQUMsUUFBUSxNQUFNO0lBQzVFLElBQUlGLEtBQUssTUFBTyxPQUFPLENBQUNBLElBQUksSUFBSSxFQUFHQyxPQUFPLENBQUMsR0FBR0MsT0FBTyxDQUFDLFFBQVEsTUFBTTtJQUNwRSxPQUFPRixFQUFFRyxRQUFRO0FBQ25CO0FBRU8sU0FBU0MscUJBQXFCQyxTQUFTO0lBQzVDLE1BQU1DLE9BQU8sSUFBSUMsS0FBS0Y7SUFDdEIsTUFBTUcsTUFBTUMsT0FBT0gsS0FBS0ksT0FBTyxJQUFJQyxRQUFRLENBQUMsR0FBRztJQUMvQyxNQUFNQyxRQUFRSCxPQUFPSCxLQUFLTyxRQUFRLEtBQUssR0FBR0YsUUFBUSxDQUFDLEdBQUcsTUFBTSx1QkFBdUI7SUFDbkYsTUFBTUcsT0FBT1IsS0FBS1MsV0FBVztJQUU3QixPQUFPLEdBQVdILE9BQVJFLE1BQUssS0FBWU4sT0FBVEksT0FBTSxLQUFPLE9BQUpKO0FBQzdCO0FBRU8sU0FBU1EsYUFBYWhCLENBQUM7SUFDNUIsT0FBT0EsRUFBRWlCLGNBQWM7QUFDekI7QUFFTyxNQUFNQyxlQUFlLENBQUNDLFNBQVdBLE1BQU0sQ0FBQyxFQUFFLENBQUNDLEdBQUcsQ0FBQyxDQUFDakMsR0FBR2tDLElBQU1GLE9BQU9DLEdBQUcsQ0FBQ0UsQ0FBQUEsTUFBT0EsR0FBRyxDQUFDRCxFQUFFLEVBQUVFLE9BQU8sSUFBSTtBQUM5RixNQUFNQyxrQkFBa0I7SUFDM0IsTUFBTUMsUUFBUW5DLEtBQUtvQyxLQUFLLENBQUNwQyxLQUFLRSxNQUFNLEtBQUtiLGlEQUFVQSxDQUFDbUIsTUFBTTtJQUMxRCxPQUFPO1FBQUU2QixPQUFPaEQsaURBQVUsQ0FBQzhDLE1BQU07UUFBRUcsT0FBT2xELHVEQUFnQixDQUFDK0MsTUFBTTtRQUFFSCxLQUFLO1FBQUdPLEtBQUs7SUFBRTtBQUN0RixFQUFFO0FBRUssTUFBTUMsVUFBVSxTQUFDQyxNQUFNQztRQUFXQyw2RUFBWSxHQUFHQyw2RUFBWSxHQUFHUCx5RUFBUTtJQUMzRSxNQUFNUSxlQUFlUixTQUFTSyxVQUFVTCxLQUFLO0lBQzdDLE9BQU9RLGFBQWFDLEtBQUssQ0FBQyxDQUFDZCxLQUFLZSxPQUM1QmYsSUFBSWMsS0FBSyxDQUFDLENBQUNFLEtBQUtDO1lBQ1osSUFBSSxDQUFDRCxLQUFLLE9BQU87WUFDakIsTUFBTUUsU0FBU1IsVUFBVVYsR0FBRyxHQUFHZSxPQUFPSjtZQUN0QyxNQUFNUSxTQUFTVCxVQUFVSCxHQUFHLEdBQUdVLE9BQU9MO1lBQ3RDLE9BQ0lNLFVBQVUsS0FDVkEsU0FBUy9ELDRDQUFLQSxDQUFDaUUsVUFBVSxJQUN6QkQsVUFBVSxLQUNWQSxTQUFTaEUsNENBQUtBLENBQUNrRSxTQUFTLElBQ3hCWixJQUFJLENBQUNTLE9BQU8sQ0FBQ0MsT0FBTyxLQUFLO1FBRWpDO0FBRVIsRUFBRTtBQUVLLE1BQU1HLFdBQVcsU0FBQ2IsTUFBTUM7UUFBV2EsNkVBQVksR0FBR0MsNkVBQVk7SUFDakUsTUFBTSxFQUFFbkIsS0FBSyxFQUFFTCxLQUFLeUIsSUFBSSxFQUFFbEIsS0FBS21CLElBQUksRUFBRSxHQUFHaEI7SUFFeEMsSUFBSyxJQUFJaUIsSUFBSSxHQUFHQSxJQUFJdEIsTUFBTTdCLE1BQU0sRUFBRW1ELElBQUs7UUFDbkMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUl2QixLQUFLLENBQUNzQixFQUFFLENBQUNuRCxNQUFNLEVBQUVvRCxJQUFLO1lBQ3RDLElBQUksQ0FBQ3ZCLEtBQUssQ0FBQ3NCLEVBQUUsQ0FBQ0MsRUFBRSxFQUFFLFVBQVUsbUJBQW1CO1lBRS9DLE1BQU1DLElBQUlKLE9BQU9FLElBQUlKO1lBQ3JCLE1BQU1PLElBQUlKLE9BQU9FLElBQUlKO1lBRXJCLDJDQUEyQztZQUMzQyxJQUFJSyxLQUFLcEIsS0FBS2pDLE1BQU0sRUFBRSxPQUFPO1lBRTdCLDRCQUE0QjtZQUM1QixJQUFJc0QsSUFBSSxLQUFLQSxLQUFLckIsSUFBSSxDQUFDLEVBQUUsQ0FBQ2pDLE1BQU0sRUFBRSxPQUFPO1lBRXpDLHNFQUFzRTtZQUN0RSxJQUFJcUQsS0FBSyxLQUFLcEIsSUFBSSxDQUFDb0IsRUFBRSxDQUFDQyxFQUFFLEVBQUUsT0FBTztRQUNyQztJQUNKO0lBRUEsT0FBTyxPQUFPLGVBQWU7QUFDakMsRUFBRTtBQUVLLE1BQU1DLG9CQUFvQixDQUFDdEIsTUFBTUM7SUFDcEMsTUFBTXNCLFNBQVM7UUFBRSxHQUFHdEIsU0FBUztRQUFFVixLQUFLVSxVQUFVVixHQUFHO0lBQUM7SUFFbEQsTUFBTyxDQUFDc0IsU0FBU2IsTUFBTXVCLFFBQVEsR0FBRyxHQUFJO1FBQ2xDQSxPQUFPaEMsR0FBRyxJQUFJO0lBQ2xCO0lBRUEsT0FBT2dDO0FBQ1gsRUFBRTtBQUVLLE1BQU1DLGlCQUFpQixTQUFDeEIsTUFBTUM7UUFBV3dCLG1GQUFrQjtJQUM5RCxNQUFNQyxVQUFVMUIsS0FBS1gsR0FBRyxDQUFDRSxDQUFBQSxNQUFPO2VBQUlBO1NBQUk7SUFDeEMsSUFBSWtDLGlCQUFpQjtRQUNqQkEsZ0JBQWdCN0IsS0FBSyxDQUFDK0IsT0FBTyxDQUFDLENBQUNwQyxLQUFLZTtZQUNoQ2YsSUFBSW9DLE9BQU8sQ0FBQyxDQUFDcEIsS0FBS0M7Z0JBQ2QsSUFBSUQsS0FBSztvQkFDTCxNQUFNYSxJQUFJSyxnQkFBZ0JsQyxHQUFHLEdBQUdlO29CQUNoQyxNQUFNZSxJQUFJSSxnQkFBZ0IzQixHQUFHLEdBQUdVO29CQUNoQyxJQUFJWSxLQUFLLEtBQUtBLElBQUkxRSw0Q0FBS0EsQ0FBQ2lFLFVBQVUsSUFBSVUsS0FBSyxLQUFLQSxJQUFJM0UsNENBQUtBLENBQUNrRSxTQUFTLElBQUljLE9BQU8sQ0FBQ04sRUFBRSxDQUFDQyxFQUFFLEtBQUssR0FBRzt3QkFDeEYsNkNBQTZDO3dCQUM3Q0ssT0FBTyxDQUFDTixFQUFFLENBQUNDLEVBQUUsR0FBRyxDQUFDLEdBQUcsZ0RBQWdEO29CQUN4RTtnQkFDSjtZQUNKO1FBQ0o7SUFDSjtJQUdBcEIsVUFBVUwsS0FBSyxDQUFDK0IsT0FBTyxDQUFDLENBQUNwQyxLQUFLZTtRQUMxQmYsSUFBSW9DLE9BQU8sQ0FBQyxDQUFDcEIsS0FBS0M7WUFDZCxJQUFJRCxLQUFLO2dCQUNMLE1BQU1hLElBQUluQixVQUFVVixHQUFHLEdBQUdlO2dCQUMxQixNQUFNZSxJQUFJcEIsVUFBVUgsR0FBRyxHQUFHVTtnQkFDMUIsSUFBSVksS0FBSyxLQUFLQSxJQUFJMUUsNENBQUtBLENBQUNpRSxVQUFVLElBQUlVLEtBQUssS0FBS0EsSUFBSTNFLDRDQUFLQSxDQUFDa0UsU0FBUyxFQUFFO29CQUNqRSxNQUFNZ0IsYUFBYWpGLHVEQUFnQkEsQ0FBQ2tGLE9BQU8sQ0FBQzVCLFVBQVVKLEtBQUs7b0JBQzNELElBQUkrQixlQUFlLENBQUMsR0FBRzt3QkFDbkJGLE9BQU8sQ0FBQ04sRUFBRSxDQUFDQyxFQUFFLEdBQUdPLGFBQWE7b0JBQ2pDO2dCQUNKO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsT0FBT0Y7QUFDWCxFQUFFO0FBRUssTUFBTUkscUJBQXFCLENBQUM5QixNQUFNQztJQUNyQyxNQUFNeUIsVUFBVTFCLEtBQUtYLEdBQUcsQ0FBQ0UsQ0FBQUEsTUFBTztlQUFJQTtTQUFJO0lBQ3hDVSxVQUFVTCxLQUFLLENBQUMrQixPQUFPLENBQUMsQ0FBQ3BDLEtBQUtlO1FBQzFCZixJQUFJb0MsT0FBTyxDQUFDLENBQUNwQixLQUFLQztZQUNkLElBQUlELEtBQUs7Z0JBQ0wsTUFBTWEsSUFBSW5CLFVBQVVWLEdBQUcsR0FBR2UsT0FBTztnQkFDakMsTUFBTWUsSUFBSXBCLFVBQVVILEdBQUcsR0FBR1UsT0FBTztnQkFDakMsSUFBSVksS0FBSyxLQUFLQSxJQUFJMUUsNENBQUtBLENBQUNxRixjQUFjLElBQUlWLEtBQUssS0FBS0EsSUFBSTNFLDRDQUFLQSxDQUFDc0YsYUFBYSxFQUFFO29CQUN6RSxNQUFNSixhQUFhakYsdURBQWdCQSxDQUFDa0YsT0FBTyxDQUFDNUIsVUFBVUosS0FBSztvQkFDM0QsSUFBSStCLGVBQWUsQ0FBQyxHQUFHO3dCQUNuQkYsT0FBTyxDQUFDTixFQUFFLENBQUNDLEVBQUUsR0FBR08sYUFBYTtvQkFDakM7Z0JBQ0o7WUFDSjtRQUNKO0lBQ0o7SUFDQSxPQUFPRjtBQUNYLEVBQUU7QUFFSyxNQUFNTyxhQUFhLENBQUNqQztJQUN2QixJQUFJa0MsVUFBVTtJQUNkLE1BQU1SLFVBQVUxQixLQUFLbUMsTUFBTSxDQUFDNUMsQ0FBQUE7UUFDeEIsSUFBSUEsSUFBSWMsS0FBSyxDQUFDK0IsQ0FBQUEsT0FBUUEsU0FBUyxJQUFJO1lBQy9CRjtZQUNBLE9BQU87UUFDWDtRQUNBLE9BQU87SUFDWDtJQUVBLE1BQU1HLGNBQWMsRUFBRTtJQUV0QnJDLEtBQUsyQixPQUFPLENBQUMsQ0FBQ3BDLEtBQUs2QjtRQUNmLElBQUk3QixJQUFJYyxLQUFLLENBQUMrQixDQUFBQSxPQUFRQSxPQUFPLElBQUk7WUFDN0JDLFlBQVlDLElBQUksQ0FBQ2xCO1FBQ3JCO0lBQ0o7SUFFQSxNQUFPTSxRQUFRM0QsTUFBTSxHQUFHckIsNENBQUtBLENBQUNpRSxVQUFVLENBQUU7UUFDdENlLFFBQVFhLE9BQU8sQ0FBQ0MsTUFBTTlGLDRDQUFLQSxDQUFDa0UsU0FBUyxFQUFFNkIsSUFBSSxDQUFDO0lBQ2hEO0lBQ0EsT0FBTztRQUFFZjtRQUFTUTtRQUFTRztJQUFZO0FBQzNDLEVBQUU7QUFFSyxTQUFTSyxZQUFZQyxHQUFHLEVBQUVDLEtBQUs7UUFBRUMsWUFBQUEsaUVBQVk7SUFDbEQsT0FBT0YsSUFBSTdFLEtBQUssR0FBR2dGLElBQUksQ0FBQyxDQUFDQyxHQUFHQztRQUMxQixJQUFJRCxDQUFDLENBQUNILE1BQU0sR0FBR0ksQ0FBQyxDQUFDSixNQUFNLEVBQUUsT0FBT0MsWUFBWSxDQUFDLElBQUk7UUFDakQsSUFBSUUsQ0FBQyxDQUFDSCxNQUFNLEdBQUdJLENBQUMsQ0FBQ0osTUFBTSxFQUFFLE9BQU9DLFlBQVksSUFBSSxDQUFDO1FBQ2pELE9BQU87SUFDVDtBQUNGO0FBRU8sZUFBZUksa0JBQWtCQyxLQUFLLEVBQUVDLEVBQUU7SUFDN0MsSUFBSTtRQUNBLE1BQU10RywrQ0FBUUEsQ0FBQ3VHLElBQUksQ0FBQyxlQUFlQyxNQUFNLENBQUM7WUFBQ0gsT0FBT0E7UUFBSyxHQUFHSSxFQUFFLENBQUMsV0FBV0g7SUFDNUUsRUFBRSxPQUFPSSxPQUFPLENBRWhCO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvZ2VuZXJhbC5qcz9iNWYyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhdWRpbyBmcm9tIFwiQC9jb21wb25lbnRzL2NvbmZpZy9hdWRpb1wiO1xyXG5pbXBvcnQgeyB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgYm9hcmQsIGZ1dHVyaXN0aWNDb2xvcnMsIHRldHJvbWlub3MgfSBmcm9tIFwiLi9jb25zdGFudFwiO1xyXG5pbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gXCIuL3N1cGFiYXNlXCI7XHJcblxyXG5leHBvcnQgY29uc3QgdG9BdWRpbyA9IHNyYyA9PiB7XHJcbiAgICBjb25zdCB0ZW1wID0gdXNlUmVmKG5ldyBBdWRpbyhzcmMpKTtcclxuXHJcbiAgICByZXR1cm4gdGVtcC5jdXJyZW50O1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0UmFuZENsZWFyU291bmQgPSBfID0+IHtcclxuICAgIGNvbnN0IGdldFJhbmQgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgbnVtID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogNSkgKyAxO1xyXG4gICAgICAgIGNvbnN0IGNsZWFyQXVkaW8gPSBhdWRpby5ibG9ja0NsZWFyKG51bSk7XHJcbiAgICAgICAgcmV0dXJuIGNsZWFyQXVkaW9cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZ2V0UmFuZCgpO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZGlzcGxheVdhbGxldCA9IGFkZHJlc3MgPT4ge1xyXG4gICAgcmV0dXJuIGFkZHJlc3Muc2xpY2UoMCwgNikgKyAoYWRkcmVzcy5sZW5ndGggPiA2ID8gXCIuLi4uXCIgOiBcIlwiKSArIGFkZHJlc3Muc2xpY2UoYWRkcmVzcy5sZW5ndGggLSA2LCBhZGRyZXNzLmxlbmd0aCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRTaG9ydE51bWJlcihuKSB7XHJcbiAgaWYgKG4gPj0gMV8wMDBfMDAwKSByZXR1cm4gKG4gLyAxXzAwMF8wMDApLnRvRml4ZWQoMSkucmVwbGFjZSgvXFwuMCQvLCAnJykgKyAnTSc7XHJcbiAgaWYgKG4gPj0gMV8wMDApIHJldHVybiAobiAvIDFfMDAwKS50b0ZpeGVkKDEpLnJlcGxhY2UoL1xcLjAkLywgJycpICsgJ0snO1xyXG4gIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREYXRlQ29tcGFyYWJsZShkYXRlSW5wdXQpIHtcclxuICBjb25zdCBkYXRlID0gbmV3IERhdGUoZGF0ZUlucHV0KTtcclxuICBjb25zdCBkYXkgPSBTdHJpbmcoZGF0ZS5nZXREYXRlKCkpLnBhZFN0YXJ0KDIsICcwJyk7XHJcbiAgY29uc3QgbW9udGggPSBTdHJpbmcoZGF0ZS5nZXRNb250aCgpICsgMSkucGFkU3RhcnQoMiwgJzAnKTsgLy8gTW9udGhzIGFyZSAwLWluZGV4ZWRcclxuICBjb25zdCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xyXG5cclxuICByZXR1cm4gYCR7eWVhcn0tJHttb250aH0tJHtkYXl9YDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE51bWJlcihuKSB7XHJcbiAgcmV0dXJuIG4udG9Mb2NhbGVTdHJpbmcoKTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHJvdGF0ZU1hdHJpeCA9IChtYXRyaXgpID0+IG1hdHJpeFswXS5tYXAoKF8sIGkpID0+IG1hdHJpeC5tYXAocm93ID0+IHJvd1tpXSkucmV2ZXJzZSgpKTtcclxuZXhwb3J0IGNvbnN0IHJhbmRvbVRldHJvbWlubyA9ICgpID0+IHtcclxuICAgIGNvbnN0IGluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGV0cm9taW5vcy5sZW5ndGgpO1xyXG4gICAgcmV0dXJuIHsgc2hhcGU6IHRldHJvbWlub3NbaW5kZXhdLCBjb2xvcjogZnV0dXJpc3RpY0NvbG9yc1tpbmRleF0sIHJvdzogMCwgY29sOiAzIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY2FuTW92ZSA9IChncmlkLCB0ZXRyb21pbm8sIG9mZnNldFJvdyA9IDAsIG9mZnNldENvbCA9IDAsIHNoYXBlID0gbnVsbCkgPT4ge1xyXG4gICAgY29uc3Qgc2hhcGVUb0NoZWNrID0gc2hhcGUgfHwgdGV0cm9taW5vLnNoYXBlO1xyXG4gICAgcmV0dXJuIHNoYXBlVG9DaGVjay5ldmVyeSgocm93LCBySWR4KSA9PlxyXG4gICAgICAgIHJvdy5ldmVyeSgodmFsLCBjSWR4KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdmFsKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc3QgbmV3Um93ID0gdGV0cm9taW5vLnJvdyArIHJJZHggKyBvZmZzZXRSb3c7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbCA9IHRldHJvbWluby5jb2wgKyBjSWR4ICsgb2Zmc2V0Q29sO1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgbmV3Um93ID49IDAgJiZcclxuICAgICAgICAgICAgICAgIG5ld1JvdyA8IGJvYXJkLmdyaWRIZWlnaHQgJiZcclxuICAgICAgICAgICAgICAgIG5ld0NvbCA+PSAwICYmXHJcbiAgICAgICAgICAgICAgICBuZXdDb2wgPCBib2FyZC5ncmlkV2lkdGggJiZcclxuICAgICAgICAgICAgICAgIGdyaWRbbmV3Um93XVtuZXdDb2xdID09PSAwXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSlcclxuICAgICk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY29sbGlkZXMgPSAoZ3JpZCwgdGV0cm9taW5vLCByb3dPZmZzZXQgPSAwLCBjb2xPZmZzZXQgPSAwKSA9PiB7XHJcbiAgICBjb25zdCB7IHNoYXBlLCByb3c6IHRSb3csIGNvbDogdENvbCB9ID0gdGV0cm9taW5vO1xyXG5cclxuICAgIGZvciAobGV0IHIgPSAwOyByIDwgc2hhcGUubGVuZ3RoOyByKyspIHtcclxuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHNoYXBlW3JdLmxlbmd0aDsgYysrKSB7XHJcbiAgICAgICAgICAgIGlmICghc2hhcGVbcl1bY10pIGNvbnRpbnVlOyAvLyBTa2lwIGVtcHR5IGNlbGxzXHJcblxyXG4gICAgICAgICAgICBjb25zdCB5ID0gdFJvdyArIHIgKyByb3dPZmZzZXQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSB0Q29sICsgYyArIGNvbE9mZnNldDtcclxuXHJcbiAgICAgICAgICAgIC8vIE91dHNpZGUgdmVydGljYWwgYm91bmRzIChib3R0b20gb2YgZ3JpZClcclxuICAgICAgICAgICAgaWYgKHkgPj0gZ3JpZC5sZW5ndGgpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICAgICAgLy8gT3V0c2lkZSBob3Jpem9udGFsIGJvdW5kc1xyXG4gICAgICAgICAgICBpZiAoeCA8IDAgfHwgeCA+PSBncmlkWzBdLmxlbmd0aCkgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgICAgICAvLyBDb2xsaWRpbmcgd2l0aCBhIGZpbGxlZCBjZWxsIChvbmx5IGNoZWNrIGlmIGluc2lkZSB2ZXJ0aWNhbCBib3VuZHMpXHJcbiAgICAgICAgICAgIGlmICh5ID49IDAgJiYgZ3JpZFt5XVt4XSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTsgLy8gTm8gY29sbGlzaW9uXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZ2V0U2hhZG93UG9zaXRpb24gPSAoZ3JpZCwgdGV0cm9taW5vKSA9PiB7XHJcbiAgICBjb25zdCBzaGFkb3cgPSB7IC4uLnRldHJvbWlubywgcm93OiB0ZXRyb21pbm8ucm93IH07XHJcblxyXG4gICAgd2hpbGUgKCFjb2xsaWRlcyhncmlkLCBzaGFkb3csIDEsIDApKSB7XHJcbiAgICAgICAgc2hhZG93LnJvdyArPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzaGFkb3c7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgbWVyZ2VUZXRyb21pbm8gPSAoZ3JpZCwgdGV0cm9taW5vLCBzaGFkb3dUZXRyb21pbm8gPSBudWxsKSA9PiB7XHJcbiAgICBjb25zdCBuZXdHcmlkID0gZ3JpZC5tYXAocm93ID0+IFsuLi5yb3ddKTtcclxuICAgIGlmIChzaGFkb3dUZXRyb21pbm8pIHtcclxuICAgICAgICBzaGFkb3dUZXRyb21pbm8uc2hhcGUuZm9yRWFjaCgocm93LCBySWR4KSA9PiB7XHJcbiAgICAgICAgICAgIHJvdy5mb3JFYWNoKCh2YWwsIGNJZHgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB5ID0gc2hhZG93VGV0cm9taW5vLnJvdyArIHJJZHg7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeCA9IHNoYWRvd1RldHJvbWluby5jb2wgKyBjSWR4O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh5ID49IDAgJiYgeSA8IGJvYXJkLmdyaWRIZWlnaHQgJiYgeCA+PSAwICYmIHggPCBib2FyZC5ncmlkV2lkdGggJiYgbmV3R3JpZFt5XVt4XSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgYSBuZWdhdGl2ZSBvciBzcGVjaWFsIHZhbHVlIGZvciBzaGFkb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3R3JpZFt5XVt4XSA9IC0xOyAvLyBvciBhIHNlcGFyYXRlIGNvbnN0YW50IGxpa2UgU0hBRE9XX0NFTEwgPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICB0ZXRyb21pbm8uc2hhcGUuZm9yRWFjaCgocm93LCBySWR4KSA9PiB7XHJcbiAgICAgICAgcm93LmZvckVhY2goKHZhbCwgY0lkeCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gdGV0cm9taW5vLnJvdyArIHJJZHg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gdGV0cm9taW5vLmNvbCArIGNJZHg7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA+PSAwICYmIHkgPCBib2FyZC5ncmlkSGVpZ2h0ICYmIHggPj0gMCAmJiB4IDwgYm9hcmQuZ3JpZFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sb3JJbmRleCA9IGZ1dHVyaXN0aWNDb2xvcnMuaW5kZXhPZih0ZXRyb21pbm8uY29sb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xvckluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdHcmlkW3ldW3hdID0gY29sb3JJbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXdHcmlkO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IG1lcmdlVGV0cm9taW5vUHJldiA9IChncmlkLCB0ZXRyb21pbm8pID0+IHtcclxuICAgIGNvbnN0IG5ld0dyaWQgPSBncmlkLm1hcChyb3cgPT4gWy4uLnJvd10pO1xyXG4gICAgdGV0cm9taW5vLnNoYXBlLmZvckVhY2goKHJvdywgcklkeCkgPT4ge1xyXG4gICAgICAgIHJvdy5mb3JFYWNoKCh2YWwsIGNJZHgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IHRldHJvbWluby5yb3cgKyBySWR4ICsgMTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB0ZXRyb21pbm8uY29sICsgY0lkeCAtIDI7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA+PSAwICYmIHkgPCBib2FyZC5ncmlkSGVpZ2h0UHJldiAmJiB4ID49IDAgJiYgeCA8IGJvYXJkLmdyaWRXaWR0aFByZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xvckluZGV4ID0gZnV0dXJpc3RpY0NvbG9ycy5pbmRleE9mKHRldHJvbWluby5jb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9ySW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0dyaWRbeV1beF0gPSBjb2xvckluZGV4ICsgMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG5ld0dyaWQ7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgY2xlYXJMaW5lcyA9IChncmlkKSA9PiB7XHJcbiAgICBsZXQgY2xlYXJlZCA9IDA7XHJcbiAgICBjb25zdCBuZXdHcmlkID0gZ3JpZC5maWx0ZXIocm93ID0+IHtcclxuICAgICAgICBpZiAocm93LmV2ZXJ5KGNlbGwgPT4gY2VsbCAhPT0gMCkpIHtcclxuICAgICAgICAgICAgY2xlYXJlZCsrO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgY2xlYXJlZFJvd3MgPSBbXTtcclxuXHJcbiAgICBncmlkLmZvckVhY2goKHJvdywgeSkgPT4ge1xyXG4gICAgICAgIGlmIChyb3cuZXZlcnkoY2VsbCA9PiBjZWxsID4gMCkpIHtcclxuICAgICAgICAgICAgY2xlYXJlZFJvd3MucHVzaCh5KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB3aGlsZSAobmV3R3JpZC5sZW5ndGggPCBib2FyZC5ncmlkSGVpZ2h0KSB7XHJcbiAgICAgICAgbmV3R3JpZC51bnNoaWZ0KEFycmF5KGJvYXJkLmdyaWRXaWR0aCkuZmlsbCgwKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBuZXdHcmlkLCBjbGVhcmVkLCBjbGVhcmVkUm93cyB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNvcnRCeUZpZWxkKGFyciwgZmllbGQsIGFzY2VuZGluZyA9IHRydWUpIHtcclxuICByZXR1cm4gYXJyLnNsaWNlKCkuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgaWYgKGFbZmllbGRdIDwgYltmaWVsZF0pIHJldHVybiBhc2NlbmRpbmcgPyAtMSA6IDE7XHJcbiAgICBpZiAoYVtmaWVsZF0gPiBiW2ZpZWxkXSkgcmV0dXJuIGFzY2VuZGluZyA/IDEgOiAtMTtcclxuICAgIHJldHVybiAwO1xyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlUmF3TWV0YUJ1bGsoc2NvcmUsIGlkKXtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgc3VwYWJhc2UuZnJvbSgnbGVhZGVyYm9hcmQnKS51cGRhdGUoe3Njb3JlOiBzY29yZX0pLmVxKFwidXNlcl9pZFwiLCBpZCk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG59Il0sIm5hbWVzIjpbImF1ZGlvIiwidXNlUmVmIiwiYm9hcmQiLCJmdXR1cmlzdGljQ29sb3JzIiwidGV0cm9taW5vcyIsInN1cGFiYXNlIiwidG9BdWRpbyIsInNyYyIsInRlbXAiLCJBdWRpbyIsImN1cnJlbnQiLCJnZXRSYW5kQ2xlYXJTb3VuZCIsIl8iLCJnZXRSYW5kIiwibnVtIiwiTWF0aCIsInJvdW5kIiwicmFuZG9tIiwiY2xlYXJBdWRpbyIsImJsb2NrQ2xlYXIiLCJkaXNwbGF5V2FsbGV0IiwiYWRkcmVzcyIsInNsaWNlIiwibGVuZ3RoIiwiZm9ybWF0U2hvcnROdW1iZXIiLCJuIiwidG9GaXhlZCIsInJlcGxhY2UiLCJ0b1N0cmluZyIsImZvcm1hdERhdGVDb21wYXJhYmxlIiwiZGF0ZUlucHV0IiwiZGF0ZSIsIkRhdGUiLCJkYXkiLCJTdHJpbmciLCJnZXREYXRlIiwicGFkU3RhcnQiLCJtb250aCIsImdldE1vbnRoIiwieWVhciIsImdldEZ1bGxZZWFyIiwiZm9ybWF0TnVtYmVyIiwidG9Mb2NhbGVTdHJpbmciLCJyb3RhdGVNYXRyaXgiLCJtYXRyaXgiLCJtYXAiLCJpIiwicm93IiwicmV2ZXJzZSIsInJhbmRvbVRldHJvbWlubyIsImluZGV4IiwiZmxvb3IiLCJzaGFwZSIsImNvbG9yIiwiY29sIiwiY2FuTW92ZSIsImdyaWQiLCJ0ZXRyb21pbm8iLCJvZmZzZXRSb3ciLCJvZmZzZXRDb2wiLCJzaGFwZVRvQ2hlY2siLCJldmVyeSIsInJJZHgiLCJ2YWwiLCJjSWR4IiwibmV3Um93IiwibmV3Q29sIiwiZ3JpZEhlaWdodCIsImdyaWRXaWR0aCIsImNvbGxpZGVzIiwicm93T2Zmc2V0IiwiY29sT2Zmc2V0IiwidFJvdyIsInRDb2wiLCJyIiwiYyIsInkiLCJ4IiwiZ2V0U2hhZG93UG9zaXRpb24iLCJzaGFkb3ciLCJtZXJnZVRldHJvbWlubyIsInNoYWRvd1RldHJvbWlubyIsIm5ld0dyaWQiLCJmb3JFYWNoIiwiY29sb3JJbmRleCIsImluZGV4T2YiLCJtZXJnZVRldHJvbWlub1ByZXYiLCJncmlkSGVpZ2h0UHJldiIsImdyaWRXaWR0aFByZXYiLCJjbGVhckxpbmVzIiwiY2xlYXJlZCIsImZpbHRlciIsImNlbGwiLCJjbGVhcmVkUm93cyIsInB1c2giLCJ1bnNoaWZ0IiwiQXJyYXkiLCJmaWxsIiwic29ydEJ5RmllbGQiLCJhcnIiLCJmaWVsZCIsImFzY2VuZGluZyIsInNvcnQiLCJhIiwiYiIsInVwZGF0ZVJhd01ldGFCdWxrIiwic2NvcmUiLCJpZCIsImZyb20iLCJ1cGRhdGUiLCJlcSIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./utils/general.js\n"));

/***/ })

});